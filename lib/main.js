// Generated by CoffeeScript 1.6.3
(function() {
  var Line_by_line, TRM, TYPES, alert, badge, debug, echo, eventually, help, info, log, njs_fs, njs_path, patterns, rpr, warn, whisper, _echo, _self, _truth_tables,
    __slice = [].slice;

  njs_fs = require('fs');

  njs_path = require('path');

  TYPES = require('coffeenode-types');

  TRM = require('coffeenode-trm');

  rpr = TRM.rpr.bind(TRM);

  badge = 'CXLTX/main';

  log = TRM.get_logger('plain', badge);

  info = TRM.get_logger('info', badge);

  whisper = TRM.get_logger('whisper', badge);

  alert = TRM.get_logger('alert', badge);

  warn = TRM.get_logger('warn', badge);

  help = TRM.get_logger('help', badge);

  _echo = TRM.echo.bind(TRM);

  eventually = process.nextTick;

  Line_by_line = require('line-by-line');

  this.aux = {};

  this.main = function() {
    var command, jobname, parameter, splitter, texroute;
    texroute = process.argv[2];
    jobname = process.argv[3];
    splitter = process.argv[4];
    command = process.argv[5];
    parameter = process.argv[6];
    this.dispatch(texroute, jobname, splitter, command, parameter, (function(_this) {
      return function(error, result) {
        if (error != null) {
          echo(debug(error));
        }
        if (result != null) {
          return echo(result);
        }
      };
    })(this));
    return null;
  };

  this.decode_unicode = function(text) {

    /* The `Buffer ... toString` steps below decode literal UTF-8 in the request */

    /* TAINT the NodeJS docs say: [the 'binary'] encoding method is deprecated and should be avoided
      [...] [it] will be removed in future versions of Node
     */
    return (new Buffer(text, 'binary')).toString('utf-8');
  };

  this.dispatch = function(texroute, jobname, splitter, command, parameter, handler) {
    var arity, idx, method, method_name, parameters, _i, _ref;
    warn('@32x', jobname, splitter, command, parameter);
    method_name = command.replace(/-/g, '_');
    if ((method = this[command]) == null) {
      return handler("Unknown command: " + (rpr(command)));
    }
    parameter = this.decode_unicode(parameter);
    parameters = (parameter != null) && parameter.length > 0 ? parameter.split(splitter) : [];
    for (idx = _i = 0, _ref = arity - 1 - parameters.length; _i < _ref; idx = _i += 1) {
      parameters.push(void 0);
    }
    this.aux['is-complete'] = false;
    this.aux['texroute'] = texroute;
    this.aux['jobname'] = jobname;
    this.aux['splitter'] = splitter;
    this.aux['method-name'] = method_name;
    this.aux['parameters'] = parameters;
    arity = method.length;
    info('©56t', this.aux);
    method.call.apply(method, [this].concat(__slice.call(parameters), [handler]));
    return null;
  };

  this.read_aux = function(handler) {
    var auxroute, jobname, labels, postprocess, texroute;
    if (this.aux['is-complete']) {
      return null;
    }
    texroute = this.aux['texroute'];
    jobname = this.aux['jobname'];
    auxroute = (njs_path.join(texroute, jobname)).concat('.auxcopy');
    if (!njs_fs.existsSync(auxroute)) {
      warn("unable to locate " + auxroute + "; ignoring");
      eventually((function(_this) {
        return function() {
          return handler(null);
        };
      })(this));
      return null;
    }
    this.aux['auxroute'] = auxroute;
    this.aux['labels'] = labels = {};
    this._lines_of(auxroute, (function(_this) {
      return function(error, line, line_nr) {
        var coffee, ignore, label, match, name, pageref, ref, source, title, type, unknown, value, x;
        if (error != null) {
          return handler(error);
        }
        if (line === null) {
          postprocess();
          _this.aux['is-complete'] = true;
          return handler(null);
        }

        /* De-escaping characters: */
        line = line.replace(_this.read_aux.protectchar_matcher, function($0, $1) {
          return String.fromCharCode(parseInt($1, 16));
        });

        /* Compiling and evaluating CoffeeScript: */
        coffee = null;
        if ((match = line.match(_this.read_aux.coffeescript_matcher)) != null) {
          if (coffee == null) {
            coffee = require('coffee-script');
          }
          try {
            source = coffee.compile(match[1], {
              'bare': true,
              'filename': auxroute
            });
            x = eval(source);
          } catch (_error) {
            error = _error;
            warn("unable to parse line " + line_nr + " of " + auxroute + ":");
            warn(line);
            warn(rpr(error));
            return null;
          }
          switch (type = TYPES.type_of(x)) {
            case 'pod':
              for (name in x) {
                value = x[name];
                _this.aux[name] = value;
              }
              break;
            default:
              warn("ignoring value of type " + type + " on line " + line_nr + " of " + auxroute + ":\n" + (rpr(line)));
          }
          return null;
        }

        /* Parsing labels and references: */
        if ((match = line.match(_this.read_aux.newlabel_matcher)) != null) {
          ignore = match[0], label = match[1], ref = match[2], pageref = match[3], title = match[4], unknown = match[5], unknown = match[6];
          labels[label] = {
            name: label,
            ref: parseInt(ref, 10),
            pageref: parseInt(pageref, 10),
            title: title
          };
          return null;
        }
      };
    })(this));
    postprocess = (function(_this) {
      return function() {

        /* Postprocessing of the data delivered by the `\auxgeo` command.
        
        All resulting lemgths are in millimeters. `firstlinev` is the distance between the
        top of the paper and the top of the first line of text. Similarly, the implicit 1 inch distance in
        `\voffset` and `\hoffset` is being made explicit so that the reference point is shifted to the paper's
        top left corner.
        
        See http://www.ctex.org/documents/packages/layout/layman.pdf p9 and
        http://en.wikibooks.org/wiki/LaTeX/Page_Layout
         */
        var g, name, one_inch, value;
        one_inch = 4736286;
        if ((g = _this.aux['geometry']) != null) {
          for (name in g) {
            value = g[name];
            if (name === 'voffset') {
              value += one_inch;
            }
            if (name === 'hoffset') {
              value += one_inch;
            }
            g[name] = (Math.round(value / 39158276 * 210 * 10000 + 0.5)) / 10000;
          }
          return g['firstlinev'] = g['voffset'] + g['topmargin'] + g['headsep'] + g['headheight'];
        }
      };
    })(this);
    return null;
  };


  /* matcher for those uber-verbosely: `\protect \char "007B\relax` escaped characters: */

  this.read_aux.protectchar_matcher = /\\protect\s+\\char\s+"([0-9A-F]+)\\relax\s?/g;


  /* matcher for CoffeeScript: */

  this.read_aux.coffeescript_matcher = /^%\s+coffee\s+(.+)$/;


  /* \newlabel{otherlabel}{{2}{3}} */


  /* \newlabel{otherlabel}{{2}{3}{References}{section.2}{}} */


  /* TAINT not sure whether this RegEx is backtracking-safe as per
    http://www.regular-expressions.info/catastrophic.html
   */

  this.read_aux.newlabel_matcher = /^\\newlabel\{([^{}]+)\}\{\{([0-9]*)\}\{([0-9]*)\}(?:\{([^{}]*)\}\{([^{}]*)\}\{([^{}]*)\})?\}$/;

  this._lines_of = function(route, handler) {
    var line_nr, line_reader;
    line_nr = 0;
    line_reader = new Line_by_line(route);
    line_reader.on('error', (function(_this) {
      return function(error) {
        return handler(error);
      };
    })(this));
    line_reader.on('end', (function(_this) {
      return function() {
        return handler(null, null);
      };
    })(this));
    line_reader.on('line', (function(_this) {
      return function(line) {
        line_nr += 1;
        return handler(null, line, line_nr);
      };
    })(this));
    return null;
  };

  this.debug = function(message) {
    if (message == null) {
      return echo();
    }
    warn(message);
    return this._pen_debug(message);
  };

  this._pen_debug = function(message) {
    message = this.escape_error(message);
    return "\\textbf{\\textcolor{red}{" + message + "}}";
  };

  this.echo = function() {
    var P;
    P = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return _echo.apply(null, P);
  };

  debug = this.debug.bind(this);

  echo = this.echo.bind(this);

  this.helo = function(name, handler) {
    return handler(null, "{Hello, " + (this.escape(name)) + "!}");
  };

  this.page_and_line_nr = function(page_nr, line_nr) {
    page_nr = parseInt(page_nr, 10);
    line_nr = parseInt(line_nr, 10);
    return "Helo from NodeJS.\nThis paragraph appears on page " + page_nr + ", column ..., line " + line_nr + ".";
  };

  this.show_geometry = function(handler) {
    return this.read_aux((function(_this) {
      return function(error) {
        var R, g, name, names, value, _i, _len;
        if (error != null) {
          return handler(error);
        }
        if ((g = _this.aux['geometry']) == null) {
          handler("unable to retrieve geometry info from " + _this.aux['auxroute'] + ";");
        }
        R = [];
        names = ((function() {
          var _results;
          _results = [];
          for (name in g) {
            _results.push(name);
          }
          return _results;
        })()).sort();
        for (_i = 0, _len = names.length; _i < _len; _i++) {
          name = names[_i];
          value = g[name];
          value = value != null ? (value.toFixed(2)).concat(' mm') : './.';
          value = value.replace(/-/g, '–');
          R.push("" + name + " & " + value);
        }
        R = R.join('\\\\\n');
        R = "\\begin{tabular}{ | l | r | }\n\\hline\n" + R + "\\\\\n\\hline\\end{tabular}";
        return handler(null, R);
      };
    })(this));
  };

  this.show_special_chrs = function(handler) {
    var R, chr, chr_by_names, name;
    chr_by_names = {
      'opening brace': '{',
      'closing brace': '}',
      'Dollar sign': '$',
      'ampersand': '&',
      'hash': '#',
      'caret': '^',
      'underscore': '_',
      'wave': '~',
      'percent sign': '%'
    };
    R = [];
    for (name in chr_by_names) {
      chr = chr_by_names[name];
      R.push("" + name + " & " + (this.escape(chr)));
    }
    R = R.join('\\\\\n');
    R = "\\begin{tabular}{ | l | c | }\n\\hline\n" + R + "\\\\\n\\hline\n\\end{tabular}";
    return handler(null, R);
  };

  this.clear_aux = function(handler) {
    var name;
    for (name in this.aux) {
      delete this.aux[name];
    }
    return handler(null);
  };

  this.show_aux = function(handler) {
    return handler(null, "\\begin{verbatim}\n" + (rpr(this.aux)) + "\n\\end{verbatim}");
  };

  this.ids_table = function(pattern, relsize, handler) {
    var bc, bl, br, fillers, mc, ml, mr, tc, tl, tr, _ref;
    if (relsize == null) {
      relsize = -5;
    }
    pattern = (_ref = this.ids_table.pattern_by_names[pattern]) != null ? _ref : pattern;
    pattern = pattern.replace(/\s+/g, '');
    if (!/^[_+*]{9}$/.test(pattern)) {
      return handler(new Error("expected a string with 9 characters out of `_`, `+`, `*` or a valid\npattern name, got " + (rpr(pattern))));
    }
    fillers = this.ids_table.fillers;
    tl = fillers[pattern[0]];
    tc = fillers[pattern[1]];
    tr = fillers[pattern[2]];
    ml = fillers[pattern[3]];
    mc = fillers[pattern[4]];
    mr = fillers[pattern[5]];
    bl = fillers[pattern[6]];
    bc = fillers[pattern[7]];
    br = fillers[pattern[8]];
    return handler(null, "\\begingroup%\n\\renewcommand{\\arraystretch}{0}%\n\\setlength{\\tabcolsep}{0mm}%\n\\jzrfont\\relsize{" + relsize + "}%\n\\begin{tabu} to 20mm { | c | c | c | }%\n\\hline\n{\\color{red}\\rule[0mm]{0mm}{0.8em}}" + tl + "&" + tc + "&" + tr + "\\\\\n\\hline\n{\\color{red}\\rule[0mm]{0mm}{0.8em}}" + ml + "&" + mc + "&" + mr + "\\\\\n\\hline\n{\\color{red}\\rule[0mm]{0mm}{0.8em}}" + bl + "&" + bc + "&" + br + "\\\\\n\\hline%\n\\end{tabu}%\n\\endgroup%");
  };

  this.ids_table.fillers = {
    '_': "\ue020",
    '+': "\ue021",
    '*': "\ue022"
  };

  this.ids_table.negate = function(pattern) {
    var R, _ref;
    R = (_ref = this.ids_table.pattern_by_names[pattern]) != null ? _ref : pattern;
    R = R.replace(/_/g, 'E');
    R = R.replace(/\*/g, '_');
    R = R.replace(/E/g, '*');
    return R;
  };

  this.ids_table.negate = this.ids_table.negate.bind(this);

  this.get_operator_method = function(operator_name) {
    var inner;
    inner = (function(_this) {
      return function(pattern_a, pattern_b) {
        var R, chr_a, chr_b, idx, idx_a, idx_b, table, _i;
        table = _this.ids_table.truth_tables[operator_name];
        R = [];
        for (idx = _i = 0; _i <= 8; idx = ++_i) {
          chr_a = pattern_a[idx];
          chr_b = pattern_b[idx];
          idx_a = _this.ids_table.trit_by_chrs[chr_a];
          idx_b = _this.ids_table.trit_by_chrs[chr_b];
          R.push(table[idx_a * 3 + idx_b]);
        }
        return R;
      };
    })(this);
    return (function(_this) {
      return function() {
        var R, arity, idx, pattern, patterns, _i, _j, _len, _ref;
        patterns = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        if (!((arity = patterns.length) >= 1)) {
          throw new Error("need at least 2 arguments, got " + arity);
        }
        for (idx = _i = 0, _len = patterns.length; _i < _len; idx = ++_i) {
          pattern = patterns[idx];
          pattern = (_ref = _this.ids_table.pattern_by_names[pattern]) != null ? _ref : pattern;
          patterns[idx] = pattern.replace(/\s+/g, '');
        }
        R = patterns[0];
        for (idx = _j = 1; 1 <= arity ? _j < arity : _j > arity; idx = 1 <= arity ? ++_j : --_j) {
          R = inner(R, patterns[idx]);
        }
        return R.join('');
      };
    })(this);
  };


  /* trit: trinary digit; https://en.wikipedia.org/wiki/Three-valued_logic */

  this.ids_table.trit_by_chrs = {
    '_': 0,
    '+': 1,
    '*': 2
  };

  this.ids_table.truth_tables = _truth_tables = {
    'and': "___\n_+*\n_**",
    'andor': "__+\n_+*\n+**",
    'or': "__*\n_+*\n***"
  };

  _self = this;

  (function() {
    var name, pattern, _results;
    _results = [];
    for (name in _truth_tables) {
      pattern = _truth_tables[name];
      _truth_tables[name] = pattern.replace(/\s+/g, '');
      _results.push(_self.ids_table[name] = _self.get_operator_method.call(_self, name));
    }
    return _results;
  })();

  this.ids_table.rotate = function(pattern, degrees) {
    var P, R, chr, direction, idx, steps, _i, _ref, _ref1, _ref2;
    if (degrees == null) {
      degrees = 90;
    }
    pattern = (_ref = this.ids_table.pattern_by_names[pattern]) != null ? _ref : pattern;
    P = pattern.replace(/\s+/g, '');
    steps = Math.abs(degrees / 90);
    if (steps === 0) {
      return P;
    }
    direction = degrees === 0 ? 0 : (degrees < 0 ? -1 : +1);
    R = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = P.length; _i < _len; _i++) {
        chr = P[_i];
        _results.push(chr);
      }
      return _results;
    })();
    for (idx = _i = 0; 0 <= steps ? _i < steps : _i > steps; idx = 0 <= steps ? ++_i : --_i) {
      if (direction === 1) {
        _ref1 = [R[6], R[3], R[0], R[7], R[4], R[1], R[8], R[5], R[2]], R[0] = _ref1[0], R[1] = _ref1[1], R[2] = _ref1[2], R[3] = _ref1[3], R[4] = _ref1[4], R[5] = _ref1[5], R[6] = _ref1[6], R[7] = _ref1[7], R[8] = _ref1[8];
      } else {
        _ref2 = [R[2], R[5], R[8], R[1], R[4], R[7], R[0], R[3], R[6]], R[0] = _ref2[0], R[1] = _ref2[1], R[2] = _ref2[2], R[3] = _ref2[3], R[4] = _ref2[4], R[5] = _ref2[5], R[6] = _ref2[6], R[7] = _ref2[7], R[8] = _ref2[8];
      }
    }
    return R.join('');
  };

  this.ids_table.rotate = this.ids_table.rotate.bind(this);

  this.ids_table.pattern_by_names = patterns = {
    'empty': '___ ___ ___',
    'full': '*** *** ***',
    'top': '*** +++ ___',
    'center-beam': '+++ *** +++',
    'bottom': '___ +++ ***',
    'left': '*+_ *+_ *+_',
    'middle-beam': '+*+ +*+ +*+',
    'right': '_+* _+* _+*',
    'top-left-corner': '*+_ ++_ ___',
    'top-I': '_*_ _+_ ___'
  };

  patterns['top-right-corner'] = this.ids_table.rotate('top-left-corner', 90);

  patterns['bottom-right-corner'] = this.ids_table.rotate('top-left-corner', 180);

  patterns['bottom-left-corner'] = this.ids_table.rotate('top-left-corner', -90);

  patterns['bottom-right-L'] = this.ids_table.negate('top-left-corner');

  patterns['bottom-left-L'] = this.ids_table.negate('top-right-corner');

  patterns['top-left-L'] = this.ids_table.negate('bottom-right-corner');

  patterns['top-right-L'] = this.ids_table.negate('bottom-left-corner');

  patterns['right-I'] = this.ids_table.rotate('top-I', 90);

  patterns['bottom-I'] = this.ids_table.rotate('top-I', 180);

  patterns['left-I'] = this.ids_table.rotate('top-I', -90);

  patterns['top-C'] = this.ids_table.negate('bottom-I');

  patterns['right-C'] = this.ids_table.negate('left-I');

  patterns['bottom-C'] = this.ids_table.negate('top-I');

  patterns['left-C'] = this.ids_table.negate('right-I');

  patterns['inner-O'] = this.ids_table.and('top', 'right', 'bottom', 'left');

  patterns['outer-O'] = this.ids_table.or('top', 'right', 'bottom', 'left');

  this._escape_replacements = [[/\\/g, '\\textbackslash{}'], [/\{/g, '\\{'], [/\}/g, '\\}'], [/&/g, '\\&'], [/\$/g, '\\$'], [/\#/g, '\\#'], [/%/g, '\\%'], [/_/g, '\\_'], [/\^/g, '\\textasciicircum{}'], [/~/g, '\\textasciitilde{}']];

  this.escape = function(text) {
    var R, matcher, replacement, _i, _len, _ref, _ref1;
    R = text;
    _ref = this._escape_replacements;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      _ref1 = _ref[_i], matcher = _ref1[0], replacement = _ref1[1];
      R = R.replace(matcher, replacement);
    }
    return R;
  };

  this.escape_error = function(text) {

    /* Escape all characters that would cause difficulties with TeX's `\verbatiminput`. */
    return (this.escape(text)).replace(/\n+/g, '\\par\n\n');
  };

  if (process.argv.length > 2) {
    this.main();
  }

}).call(this);
