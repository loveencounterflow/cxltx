// Generated by CoffeeScript 1.6.3
(function() {
  var Line_by_line, TRM, TYPES, alert, badge, debug, echo, eventually, help, info, log, njs_fs, njs_path, rpr, warn, whisper, _echo,
    __slice = [].slice;

  njs_fs = require('fs');

  njs_path = require('path');

  TYPES = require('coffeenode-types');

  TRM = require('coffeenode-trm');

  rpr = TRM.rpr.bind(TRM);

  badge = 'CXLTX/main';

  log = TRM.get_logger('plain', badge);

  info = TRM.get_logger('info', badge);

  whisper = TRM.get_logger('whisper', badge);

  alert = TRM.get_logger('alert', badge);

  warn = TRM.get_logger('warn', badge);

  help = TRM.get_logger('help', badge);

  _echo = TRM.echo.bind(TRM);

  eventually = process.nextTick;

  Line_by_line = require('line-by-line');

  this.aux = {};

  this.main = function() {
    var P, command, method_name, parameter, texroute;
    info("©45 argv: " + (rpr(process.argv)));
    texroute = process.argv[2];
    command = process.argv[3];
    method_name = command.replace(/-/g, '_');
    parameter = process.argv[4];

    /* TAINT we naïvely split on comma, which is not robust in case e.g. string or list literals contain
    that character. Instead, we should be doing parsing (eg. using JSON? CoffeeScript expressions /
    signatures?)
     */
    P = (parameter != null) && parameter.length > 0 ? parameter.split(',') : [];
    this.dispatch.apply(this, [texroute, method_name].concat(__slice.call(P), [(function(_this) {
      return function(error, result) {
        if (error != null) {
          debug(error);
        }
        if (result != null) {
          return echo(result);
        }
      };
    })(this)]));
    return null;
  };

  this.dispatch = function() {
    var P, handler, method_name, texroute, _i;
    texroute = arguments[0], method_name = arguments[1], P = 4 <= arguments.length ? __slice.call(arguments, 2, _i = arguments.length - 1) : (_i = 2, []), handler = arguments[_i++];
    if (this[method_name] == null) {
      return handler("Unknown command: " + (rpr(command)));
    }
    this.aux['is-complete'] = false;
    this.aux['texroute'] = texroute;
    this.aux['method-name'] = method_name;
    this.aux['parameters'] = P;
    info('©56t', P);
    this[method_name].apply(this, __slice.call(P).concat([handler]));
    return null;
  };

  this.read_aux = function(handler) {
    var auxroute, labels, last_idx, postprocess, texroute;
    if (this.aux['is-complete']) {
      return null;
    }
    texroute = this.aux['texroute'];
    last_idx = texroute.length - 1 - (njs_path.extname(texroute)).length;
    auxroute = texroute.slice(0, +last_idx + 1 || 9e9).concat('.auxcopy');
    if (!njs_fs.existsSync(auxroute)) {
      warn("unable to locate " + auxroute + "; ignoring");
      eventually((function(_this) {
        return function() {
          return handler(null);
        };
      })(this));
      return null;
    }
    this.aux['auxroute'] = auxroute;
    this.aux['labels'] = labels = {};
    this._lines_of(auxroute, (function(_this) {
      return function(error, line, line_nr) {
        var coffee, ignore, label, match, name, pageref, ref, source, title, type, unknown, value, x;
        if (error != null) {
          return handler(error);
        }
        if (line === null) {
          postprocess();
          return handler(null);
        }

        /* De-escaping characters: */
        line = line.replace(_this.read_aux.protectchar_matcher, function($0, $1) {
          return String.fromCharCode(parseInt($1, 16));
        });

        /* Compiling and evaluating CoffeeScript: */
        coffee = null;
        if ((match = line.match(_this.read_aux.coffeescript_matcher)) != null) {
          if (coffee == null) {
            coffee = require('coffee-script');
          }
          try {
            source = coffee.compile(match[1], {
              'bare': true,
              'filename': auxroute
            });
            x = eval(source);
          } catch (_error) {
            error = _error;
            warn("unable to parse line " + line_nr + " of " + auxroute + ":");
            warn(line);
            warn(rpr(error));
            return null;
          }
          switch (type = TYPES.type_of(x)) {
            case 'pod':
              for (name in x) {
                value = x[name];
                _this.aux[name] = value;
              }
              break;
            default:
              warn("ignoring value of type " + type + " on line " + line_nr + " of " + auxroute + ":\n" + (rpr(line)));
          }
          return null;
        }

        /* Parsing labels and references: */
        if ((match = line.match(_this.read_aux.newlabel_matcher)) != null) {
          ignore = match[0], label = match[1], ref = match[2], pageref = match[3], title = match[4], unknown = match[5], unknown = match[6];
          labels[label] = {
            name: label,
            ref: parseInt(ref, 10),
            pageref: parseInt(pageref, 10),
            title: title
          };
          return null;
        }
      };
    })(this));
    postprocess = (function(_this) {
      return function() {

        /* Postprocessing of the data delivered by the `\auxgeo` command.
        
        All resulting lemgths are in millimeters. `firstlinev` is the distance between the
        top of the paper and the top of the first line of text. Similarly, the implicit 1 inch distance in
        `\voffset` and `\hoffset` is being made explicit so that the reference point is shifted to the paper's
        top left corner.
        
        See http://www.ctex.org/documents/packages/layout/layman.pdf p9 and
        http://en.wikibooks.org/wiki/LaTeX/Page_Layout
         */
        var g, name, one_inch, value;
        one_inch = 4736286;
        if ((g = _this.aux['geometry']) != null) {
          for (name in g) {
            value = g[name];
            if (name === 'voffset') {
              value += one_inch;
            }
            if (name === 'hoffset') {
              value += one_inch;
            }
            g[name] = (Math.round(value / 39158276 * 210 * 10000 + 0.5)) / 10000;
          }
          return g['firstlinev'] = g['voffset'] + g['topmargin'] + g['headsep'] + g['headheight'];
        }
      };
    })(this);
    return null;
  };


  /* matcher for those uber-verbosely: `\protect \char "007B\relax` escaped characters: */

  this.read_aux.protectchar_matcher = /\\protect\s+\\char\s+"([0-9A-F]+)\\relax\s?/g;


  /* matcher for CoffeeScript: */

  this.read_aux.coffeescript_matcher = /^%\s+coffee\s+(.+)$/;


  /* \newlabel{otherlabel}{{2}{3}} */


  /* \newlabel{otherlabel}{{2}{3}{References}{section.2}{}} */


  /* TAINT not sure whether this RegEx is backtracking-safe as per
    http://www.regular-expressions.info/catastrophic.html
   */

  this.read_aux.newlabel_matcher = /^\\newlabel\{([^{}]+)\}\{\{([0-9]*)\}\{([0-9]*)\}(?:\{([^{}]*)\}\{([^{}]*)\}\{([^{}]*)\})?\}$/;

  this._lines_of = function(route, handler) {
    var line_nr, line_reader;
    line_nr = 0;
    line_reader = new Line_by_line(route);
    line_reader.on('error', (function(_this) {
      return function(error) {
        return handler(error);
      };
    })(this));
    line_reader.on('end', (function(_this) {
      return function() {
        return handler(null, null);
      };
    })(this));
    line_reader.on('line', (function(_this) {
      return function(line) {
        line_nr += 1;
        return handler(null, line, line_nr);
      };
    })(this));
    return null;
  };

  this.debug = function(message) {
    if (message == null) {
      return echo();
    }
    return this._pen_debug(message);
  };

  this._pen_debug = function(message) {
    return "\\textbf{\\textcolor{red}{" + (this.escape(message.replace(/\n+/g, '\\par\\n\\n'))) + "}}";
  };

  this.echo = function() {
    var P;
    P = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    whisper.apply(null, P);
    return _echo.apply(null, P);
  };

  debug = this.debug.bind(this);

  echo = this.echo.bind(this);

  this.helo = function(name, handler) {
    return handler(null, "{Hello, \\textcolor{blue}{" + (this.escape(name)) + "}!}");
  };

  this.page_and_line_nr = function(page_nr, line_nr) {
    page_nr = parseInt(page_nr, 10);
    line_nr = parseInt(line_nr, 10);
    return "Helo from NodeJS.\nThis paragraph appears on page " + page_nr + ", column ..., line " + line_nr + ".";
  };

  this.show_geometry = function() {
    var R, g, message, name, names, value, _i, _len;
    if ((g = this.aux['geometry']) == null) {
      message = "unable to retrieve geometry info from " + this.aux['auxroute'] + ";";
      debug(message);
      return message;
    }
    R = [];
    names = ((function() {
      var _results;
      _results = [];
      for (name in g) {
        _results.push(name);
      }
      return _results;
    })()).sort();
    for (_i = 0, _len = names.length; _i < _len; _i++) {
      name = names[_i];
      value = g[name];
      value = value != null ? (value.toFixed(2)).concat(' mm') : './.';
      value = value.replace(/-/g, '–');
      R.push("" + name + " & " + value);
    }
    R = R.join('\\\\\n');
    R = "\\begin{tabular}{ | l | r | }\n\\hline\n" + R + "\\\\\n\\hline\\end{tabular}";
    return R;
  };

  this.show_special_chrs = function(handler) {
    var R, chr, chr_by_names, name;
    chr_by_names = {
      'opening brace': '{',
      'closing brace': '}',
      'Dollar sign': '$',
      'ampersand': '&',
      'hash': '#',
      'caret': '^',
      'underscore': '_',
      'wave': '~',
      'percent sign': '%'
    };
    R = [];
    for (name in chr_by_names) {
      chr = chr_by_names[name];
      R.push("" + name + " & " + (this.escape(chr)));
    }
    R = R.join('\\\\\n');
    R = "\\begin{tabular}{ | l | c | }\n\\hline\n" + R + "\\\\\n\\hline\n\\end{tabular}";
    return handler(null, R);
  };

  this.show_aux = function(handler) {
    return this.read_aux((function(_this) {
      return function(error) {
        if (error != null) {
          return handler(error);
        }
        return handler(null, "\\begin{verbatim}" + (rpr(_this.aux)) + "\\end{verbatim}");
      };
    })(this));
  };

  this._escape_replacements = [[/\\/g, '\\textbackslash{}'], [/\{/g, '\\{'], [/\}/g, '\\}'], [/&/g, '\\&'], [/\$/g, '\\$'], [/\#/g, '\\#'], [/%/g, '\\%'], [/_/g, '\\_'], [/\^/g, '\\textasciicircum{}'], [/~/g, '\\textasciitilde{}']];

  this.escape = function(text) {
    var R, matcher, replacement, _i, _len, _ref, _ref1;
    R = text;
    _ref = this._escape_replacements;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      _ref1 = _ref[_i], matcher = _ref1[0], replacement = _ref1[1];
      R = R.replace(matcher, replacement);
    }
    return R;
  };

  if (process.argv.length > 2) {
    this.main();
  }

}).call(this);
