// Generated by CoffeeScript 1.8.0
(function() {
  var CXLTX, TRM, alert, badge, debug, echo, help, info, log, rpr, warn, whisper,
    __slice = [].slice;

  TRM = require('coffeenode-trm');

  rpr = TRM.rpr.bind(TRM);

  badge = 'CXLTX/sample-provider';

  log = TRM.get_logger('plain', badge);

  info = TRM.get_logger('info', badge);

  whisper = TRM.get_logger('whisper', badge);

  alert = TRM.get_logger('alert', badge);

  debug = TRM.get_logger('debug', badge);

  warn = TRM.get_logger('warn', badge);

  help = TRM.get_logger('help', badge);

  echo = TRM.echo.bind(TRM);

  CXLTX = require('./main');

  this.helo = function(name, handler) {
    return handler(null, "{Hello, " + (CXLTX.escape(name)) + "!}");
  };

  this.page_and_line_nr = function(page_nr, line_nr, handler) {
    page_nr = parseInt(page_nr, 10);
    line_nr = parseInt(line_nr, 10);
    return handler(null, "Helo from NodeJS.\nThis paragraph appears on page " + page_nr + ", column ..., line " + line_nr + ".");
  };

  this.show_geometry = function(handler) {
    return CXLTX.read_aux((function(_this) {
      return function(error, aux) {
        var R, g, name, names, value, _i, _len;
        if (error != null) {
          return handler(error);
        }
        if ((g = aux['geometry']) == null) {
          return handler("unable to retrieve geometry info from " + CXLTX.aux['auxroute'] + ";");
        }
        R = [];
        names = ((function() {
          var _results;
          _results = [];
          for (name in g) {
            _results.push(name);
          }
          return _results;
        })()).sort();
        for (_i = 0, _len = names.length; _i < _len; _i++) {
          name = names[_i];
          value = g[name];
          value = value != null ? (value.toFixed(2)).concat(' mm') : './.';
          value = value.replace(/-/g, 'â€“');
          R.push("" + name + " & " + value);
        }
        R = R.join('\\\\\n');
        R = "\\begin{tabular}{ | l | r | }\n\\hline\n" + R + "\\\\\n\\hline\\end{tabular}";
        return handler(null, R);
      };
    })(this));
  };

  this.show_special_chrs = function(handler) {
    var R, chr, chr_by_names, name;
    chr_by_names = {
      'opening brace': '{',
      'closing brace': '}',
      'Dollar sign': '$',
      'ampersand': '&',
      'hash': '#',
      'caret': '^',
      'underscore': '_',
      'wave': '~',
      'percent sign': '%'
    };
    R = [];
    for (name in chr_by_names) {
      chr = chr_by_names[name];
      R.push("" + name + " & " + (CXLTX.escape(chr)));
    }
    R = R.join('\\\\\n');
    R = "\\begin{tabular}{ | l | c | }\n\\hline\n" + R + "\\\\\n\\hline\n\\end{tabular}";
    return handler(null, R);
  };

  this.clear_aux = function(handler) {
    var name;
    for (name in CXLTX.aux) {
      delete CXLTX.aux[name];
    }
    return handler(null, '');
  };

  this.show_aux = function(handler) {
    return handler(null, "\\begin{verbatim}\n" + (rpr(CXLTX.aux)) + "\n\\end{verbatim}");
  };

  this.show_labels = function(handler) {
    return CXLTX.read_aux((function(_this) {
      return function(error, aux) {
        var R, duplicate_label, dupmark, label, labels, name, _i, _j, _len, _len1, _ref, _ref1;
        if (error != null) {
          return handler(error);
        }
        R = [];
        labels = [];
        _ref = aux['labels'];
        for (name in _ref) {
          label = _ref[name];
          if (label['is-duplicate']) {
            _ref1 = aux['duplicate-labels'][name];
            for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
              duplicate_label = _ref1[_i];
              labels.push(duplicate_label);
            }
            continue;
          }
          labels.push(label);
        }
        labels.sort(function(a, b) {

          /* TAINT what with roman numbers? */
          var a_is_dup, b_is_dup, pageref_a, pageref_b, ref_a, ref_b;
          pageref_a = parseInt(a['pageref'], 10);
          pageref_b = parseInt(b['pageref'], 10);
          ref_a = a['ref'];
          ref_b = b['ref'];
          a_is_dup = a['is-duplicate'];
          b_is_dup = b['is-duplicate'];
          if (a_is_dup && !b_is_dup) {
            return -1;
          }
          if (b_is_dup && !a_is_dup) {
            return +1;
          }
          if (pageref_a < pageref_b) {
            return -1;
          }
          if (pageref_a > pageref_b) {
            return +1;
          }
          if (ref_a < ref_b) {
            return -1;
          }
          if (ref_a > ref_b) {
            return +1;
          }
          return 0;
        });
        debug(labels);
        R.push("\\begin{tabular}{ | r | l | l | l | l | }");
        R.push("\\hline");
        R.push("& name & pageref & ref & title\\\\");
        R.push("\\hline");
        for (_j = 0, _len1 = labels.length; _j < _len1; _j++) {
          label = labels[_j];
          dupmark = label['is-duplicate'] ? '!' : '';
          R.push("" + dupmark + " & " + label['name'] + " & " + label['pageref'] + " & " + label['ref'] + " & " + label['title'] + "\\\\");
        }
        R.push("\\hline");
        R.push("\\end{tabular}");
        return handler(null, R.join('\n'));
      };
    })(this));
  };

  this.add = function() {
    var P, R, handler, idx, p, _i, _j, _k, _len, _len1;
    P = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), handler = arguments[_i++];
    for (idx = _j = 0, _len = P.length; _j < _len; idx = ++_j) {
      p = P[idx];
      P[idx] = parseFloat(p, 10);
    }
    debug(P);
    R = 0;
    for (_k = 0, _len1 = P.length; _k < _len1; _k++) {
      p = P[_k];
      R += p;
    }
    if (!isFinite(R)) {
      return handler(new Error("unable to sum up " + (rpr(P))));
    }
    return handler(null, R);
  };

  this.gimme_five = function(n, handler) {
    return handler(null, "" + n);
  };

  this.f = function(label, fontsize_pt_txt, y_sp_txt, handler) {

    /* TAINT paperheight must come from LaTeX document */
    var delta_grid_row_2, fontsize_mm, fontsize_mm_txt, fontsize_pt, grid_row, grid_row_2, lineheight_mm, margin_top_mm, nearest_grid_row, paperheight_mm, pt_from_mm, raise_by_mm, raise_by_mm_txt, raise_relatively, sp_from_mm, sp_from_pt, y_mm, y_mm_txt, y_sp;
    paperheight_mm = 98;
    margin_top_mm = 14;
    lineheight_mm = 4.6667;
    sp_from_pt = 65536;
    pt_from_mm = 2.845274;
    sp_from_mm = sp_from_pt * pt_from_mm;
    fontsize_pt = parseFloat(fontsize_pt_txt, 10);
    y_sp = parseFloat(y_sp_txt, 10);
    fontsize_mm = fontsize_pt / pt_from_mm;
    y_mm = paperheight_mm - y_sp / sp_from_mm;
    grid_row = (y_mm - margin_top_mm) / lineheight_mm;
    grid_row_2 = (Math.floor(grid_row * 100 + 0.5)) / 100;
    nearest_grid_row = Math.floor(grid_row_2 + 0.5);
    delta_grid_row_2 = nearest_grid_row - grid_row_2;
    raise_by_mm = -delta_grid_row_2 * lineheight_mm;
    raise_relatively = raise_by_mm / fontsize_mm;
    fontsize_mm_txt = fontsize_mm.toFixed(2);
    y_mm_txt = y_mm.toFixed(2);
    raise_by_mm_txt = raise_by_mm.toFixed(2);
    info("label " + label + " y:                       " + y_mm_txt + "mm");
    info("label " + label + " fontsize:                " + fontsize_mm_txt + "mm");
    info("label " + label + " lineheight:              " + lineheight_mm + "mm");
    info("label " + label + " paperheight:             " + paperheight_mm + "mm");
    info("label " + label + " margin top:              " + margin_top_mm + "mm");
    info("label " + label + " grid row:                " + grid_row);
    info("label " + label + " grid row rounded:        " + grid_row_2);
    info("label " + label + " nearest grid row:        " + nearest_grid_row);
    info("label " + label + " delta grid row rounded:  " + delta_grid_row_2);
    info("label " + label + " raise by:                " + raise_by_mm_txt + "mm");
    return handler(null, "" + raise_relatively);
  };

}).call(this);
