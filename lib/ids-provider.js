// Generated by CoffeeScript 1.8.0
(function() {
  var patterns, _self, _truth_tables,
    __slice = [].slice;

  this.ids_table = function(pattern, relsize, handler) {
    var bc, bl, br, fillers, mc, ml, mr, tc, tl, tr, _ref;
    if (relsize == null) {
      relsize = -5;
    }
    pattern = (_ref = this.ids_table.pattern_by_names[pattern]) != null ? _ref : pattern;
    pattern = pattern.replace(/\s+/g, '');
    if (!/^[_+*]{9}$/.test(pattern)) {
      return handler(new Error("expected a string with 9 characters out of `_`, `+`, `*` or a valid\npattern name, got " + (rpr(pattern))));
    }
    fillers = this.ids_table.fillers;
    tl = fillers[pattern[0]];
    tc = fillers[pattern[1]];
    tr = fillers[pattern[2]];
    ml = fillers[pattern[3]];
    mc = fillers[pattern[4]];
    mr = fillers[pattern[5]];
    bl = fillers[pattern[6]];
    bc = fillers[pattern[7]];
    br = fillers[pattern[8]];
    return handler(null, "\\begingroup%\n\\renewcommand{\\arraystretch}{0}%\n\\setlength{\\tabcolsep}{0mm}%\n\\jzrfont\\relsize{" + relsize + "}%\n\\begin{tabu} to 20mm { | c | c | c | }%\n\\hline\n{\\color{red}\\rule[0mm]{0mm}{0.8em}}" + tl + "&" + tc + "&" + tr + "\\\\\n\\hline\n{\\color{red}\\rule[0mm]{0mm}{0.8em}}" + ml + "&" + mc + "&" + mr + "\\\\\n\\hline\n{\\color{red}\\rule[0mm]{0mm}{0.8em}}" + bl + "&" + bc + "&" + br + "\\\\\n\\hline%\n\\end{tabu}%\n\\endgroup%");
  };

  this.ids_table.fillers = {
    '_': "\ue020",
    '+': "\ue021",
    '*': "\ue022"
  };

  this.ids_table.negate = function(pattern) {
    var R, _ref;
    R = (_ref = this.ids_table.pattern_by_names[pattern]) != null ? _ref : pattern;
    R = R.replace(/_/g, 'E');
    R = R.replace(/\*/g, '_');
    R = R.replace(/E/g, '*');
    return R;
  };

  this.ids_table.negate = this.ids_table.negate.bind(this);

  this.get_operator_method = function(operator_name) {
    var inner;
    inner = (function(_this) {
      return function(pattern_a, pattern_b) {
        var R, chr_a, chr_b, idx, idx_a, idx_b, table, _i;
        table = _this.ids_table.truth_tables[operator_name];
        R = [];
        for (idx = _i = 0; _i <= 8; idx = ++_i) {
          chr_a = pattern_a[idx];
          chr_b = pattern_b[idx];
          idx_a = _this.ids_table.trit_by_chrs[chr_a];
          idx_b = _this.ids_table.trit_by_chrs[chr_b];
          R.push(table[idx_a * 3 + idx_b]);
        }
        return R;
      };
    })(this);
    return (function(_this) {
      return function() {
        var R, arity, idx, pattern, patterns, _i, _j, _len, _ref;
        patterns = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        if (!((arity = patterns.length) >= 1)) {
          throw new Error("need at least 2 arguments, got " + arity);
        }
        for (idx = _i = 0, _len = patterns.length; _i < _len; idx = ++_i) {
          pattern = patterns[idx];
          pattern = (_ref = _this.ids_table.pattern_by_names[pattern]) != null ? _ref : pattern;
          patterns[idx] = pattern.replace(/\s+/g, '');
        }
        R = patterns[0];
        for (idx = _j = 1; 1 <= arity ? _j < arity : _j > arity; idx = 1 <= arity ? ++_j : --_j) {
          R = inner(R, patterns[idx]);
        }
        return R.join('');
      };
    })(this);
  };


  /* trit: trinary digit; https://en.wikipedia.org/wiki/Three-valued_logic */

  this.ids_table.trit_by_chrs = {
    '_': 0,
    '+': 1,
    '*': 2
  };

  this.ids_table.truth_tables = _truth_tables = {
    'and': "___\n_+*\n_**",
    'andor': "__+\n_+*\n+**",
    'or': "__*\n_+*\n***"
  };

  _self = this;

  (function() {
    var name, pattern, _results;
    _results = [];
    for (name in _truth_tables) {
      pattern = _truth_tables[name];
      _truth_tables[name] = pattern.replace(/\s+/g, '');
      _results.push(_self.ids_table[name] = _self.get_operator_method.call(_self, name));
    }
    return _results;
  })();

  this.ids_table.rotate = function(pattern, degrees) {
    var P, R, chr, direction, idx, steps, _i, _ref, _ref1, _ref2;
    if (degrees == null) {
      degrees = 90;
    }
    pattern = (_ref = this.ids_table.pattern_by_names[pattern]) != null ? _ref : pattern;
    P = pattern.replace(/\s+/g, '');
    steps = Math.abs(degrees / 90);
    if (steps === 0) {
      return P;
    }
    direction = degrees === 0 ? 0 : (degrees < 0 ? -1 : +1);
    R = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = P.length; _i < _len; _i++) {
        chr = P[_i];
        _results.push(chr);
      }
      return _results;
    })();
    for (idx = _i = 0; 0 <= steps ? _i < steps : _i > steps; idx = 0 <= steps ? ++_i : --_i) {
      if (direction === 1) {
        _ref1 = [R[6], R[3], R[0], R[7], R[4], R[1], R[8], R[5], R[2]], R[0] = _ref1[0], R[1] = _ref1[1], R[2] = _ref1[2], R[3] = _ref1[3], R[4] = _ref1[4], R[5] = _ref1[5], R[6] = _ref1[6], R[7] = _ref1[7], R[8] = _ref1[8];
      } else {
        _ref2 = [R[2], R[5], R[8], R[1], R[4], R[7], R[0], R[3], R[6]], R[0] = _ref2[0], R[1] = _ref2[1], R[2] = _ref2[2], R[3] = _ref2[3], R[4] = _ref2[4], R[5] = _ref2[5], R[6] = _ref2[6], R[7] = _ref2[7], R[8] = _ref2[8];
      }
    }
    return R.join('');
  };

  this.ids_table.rotate = this.ids_table.rotate.bind(this);

  this.ids_table.pattern_by_names = patterns = {
    'empty': '___ ___ ___',
    'full': '*** *** ***',
    'top': '*** +++ ___',
    'center-beam': '+++ *** +++',
    'bottom': '___ +++ ***',
    'left': '*+_ *+_ *+_',
    'middle-beam': '+*+ +*+ +*+',
    'right': '_+* _+* _+*',
    'top-left-corner': '*+_ ++_ ___',
    'top-I': '_*_ _+_ ___'
  };

  patterns['top-right-corner'] = this.ids_table.rotate('top-left-corner', 90);

  patterns['bottom-right-corner'] = this.ids_table.rotate('top-left-corner', 180);

  patterns['bottom-left-corner'] = this.ids_table.rotate('top-left-corner', -90);

  patterns['bottom-right-L'] = this.ids_table.negate('top-left-corner');

  patterns['bottom-left-L'] = this.ids_table.negate('top-right-corner');

  patterns['top-left-L'] = this.ids_table.negate('bottom-right-corner');

  patterns['top-right-L'] = this.ids_table.negate('bottom-left-corner');

  patterns['right-I'] = this.ids_table.rotate('top-I', 90);

  patterns['bottom-I'] = this.ids_table.rotate('top-I', 180);

  patterns['left-I'] = this.ids_table.rotate('top-I', -90);

  patterns['top-C'] = this.ids_table.negate('bottom-I');

  patterns['right-C'] = this.ids_table.negate('left-I');

  patterns['bottom-C'] = this.ids_table.negate('top-I');

  patterns['left-C'] = this.ids_table.negate('right-I');

  patterns['inner-O'] = this.ids_table.and('top', 'right', 'bottom', 'left');

  patterns['outer-O'] = this.ids_table.or('top', 'right', 'bottom', 'left');

}).call(this);
